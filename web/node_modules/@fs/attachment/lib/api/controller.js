/**
 * Created by Julin on 2021/04/02.
 */
'use strict';

const request = require('superagent');
const parse = require('async-busboy');
const path = require('path');

function isValidFile(fileName) {
    let fileTypes = /jpe?g|bmp|gif|png|svg|msword|pdf|text|zip|docx?|txt|xlsx?|log|dwg|js|mp4|octet-stream/;
    let fileExtName = path.extname(fileName).toLowerCase();
    let extname = fileTypes.test(fileExtName);
    return extname;
}

function upload(attachment) {
    return async function (ctx, next) {
        let fkey = null;
        let furl = null;
        let error = { name: 'PostError', message: '文件上传失败' };
        const { uploadedBy } = ctx.query;
        try {
            const { p } = ctx.params;
            const { files } = await parse(ctx.req);
            const file = files[0];
            if (!isValidFile(file.filename)) {
                error = { name: 'PostError', error: '文件格式不支持' };
            } else {
                const fileInfo = await attachment.upload(file, { uploadPath: p });
                fkey = fileInfo.key;
                furl = fileInfo.url;
                error = null;
            }
        } catch (err) {
            ctx.fs.logger.error(`path: ${ctx.path}, error: ${err}`);
        }
        if (error) {
            ctx.status = 400;
            ctx.body = error;
        } else {
            ctx.status = 200;
            ctx.body = {
                uploaded: uploadedBy == 'url' ? furl : fkey, // 默认返回 key 值
                key: fkey,
                url: furl
            };
        }
    }
}

function download(attachment) {
    return async function (ctx, next) {
        try {
            const { src, filename } = ctx.query;
            const fkey = src.replace(/\.json$/, '.js');
            const publicDownloadUrl = await attachment.download(fkey);
            if (filename) ctx.attachment(filename);
            ctx.status = 200;
            ctx.body = request.get(publicDownloadUrl);
        } catch (err) {
            ctx.fs.logger.error(`path: GET${ctx.path}, error: ${err}`);
            ctx.status = 400;
            ctx.body = { name: 'FindError', message: '文件下载失败' }
        }
    }
}

function deletee(attachment) {
    return async function (ctx, next) {
        try {
            const { src } = ctx.query;
            await attachment.remove(src);
            ctx.status = 204;
        } catch (err) {
            ctx.status = 400;
            ctx.fs.logger.error(`path: DELETE${ctx.path}, error: ${err}`);
            ctx.body = { name: 'DeleteError', message: '文件删除失败' };
        }
    }
}

function bulkDelete(attachment) {
    return async function (ctx, next) {
        try {
            const fkeys = ctx.request.body.srcs;
            if (!Array.isArray(fkeys)) throw 'fkeys must be an array.'
            for (let i = 0; i < fkeys.length; i++) {
                await attachment.remove(fkeys[i]);
            }
            ctx.status = 200;
            ctx.body = { keys: fkeys };
        } catch (err) {
            ctx.status = 400;
            ctx.fs.logger.error(`path: POST${ctx.path}, error: ${err}`);
            ctx.body = { name: 'PostError', message: '文件批量删除失败' };
        }
    }
}

module.exports = {
    upload,
    download,
    deletee,
    bulkDelete
};
